# Patient-Manager
This program keeps track of patients with a priority queue. It utilizes binary heaps, priority queue, and heap sort data structures and algorithms.

 The program begins by presenting the user with a menu. The user can either add a patient to the queue, retrieve all the patients form the queue in order of priority, remove a patient with the highest priority, or exit the program. If the user chooses to add a patient, they are prompted to input the patient’s first name, injury, and priority number.  

 This program contains three classes: A patient class, a patient queue class, and a main class. In the patient class, three private fields are initialized: a string name, a string injury, and an integer priority. There is a constructor in this class that will be used to create instances of the Patient class, and there are getter methods that return the name, injury, and priority number.

In the patient queue class, 5 private fields are initialized. First, there’s an array of Patient objects initialized. Then, there’s integers for the array size, data size, front, and rear. These will be used to store the array of Patient objects in a queue. There is a constructor that sets the array size to 20. In an enqueue method, a decision structure is first used in order to determine if the queue is full or not. If it isn’t, the method accepts the parameter of a Patient object and puts it at the rear of the array. After doing this, the rear is set to wrap around to the beginning of the array. The data size increases, and the sort method is called.

The heap sort method first builds a max heap from the array by calling the a function that does this. Then, it repeatedly swaps the root (maximum element) with the last element in the heap, reduces the heap size, and heapifies the root again to maintain the max heap property. The function that builds a max heap from the array starts from the last non-leaf node and heapifies downwards by calling the heapify function, ensuring the entire array satisfies the max heap property. The heapify method starts with the assumption that the largest value is at the current index. If the left child exists and is larger than the current largest value, it updates the largest value to be the left child. If the right child exists and is larger than the current largest value, it updates the largest value to be the right child. If the largest value is not the current index, it swaps the values and recursively calls itself to heapify the affected sub-tree.

Moreover, there is a method that dequeues a Patient based on the priority number. This method first initializes by setting the parent index to the root, storing the top priority element. The method then replaces the root with the last element in the heap and decrements the size. Lastly, it calls the sort priority method to fix the remaining binary heap.

Next, there is a method to display the objects in the heap by utilizing a for loop. These objects are already in order of priority due to the sort priority method. 

Lastly, in main, the program enters a while loop that will break once the user decides to exit. It has a decision structure that will determine the user’s choice. If the user decides to enqueue a patient, the program stores the information provided by the user into string variables and an integer variable and passes it to an instance of the Patient class. This instance is then sent to the enqueue method of the queue class. If the user decides to retrieve the Patients based on priority, the display queue method is called from the queue class. If the user decides to dequeue a patient based on priority, the dequeue method from the queue class is called and the removed patient object is stored in a new patient object. This object is then used to display the info of the removed patient object. 
